{-# LANGUAGE DuplicateRecordFields     #-}
{-# LANGUAGE FlexibleContexts          #-}
{-# LANGUAGE FlexibleInstances         #-}
{-# LANGUAGE GADTs                     #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE OverloadedStrings         #-}
{-# LANGUAGE RecordWildCards           #-}
{-# LANGUAGE ScopedTypeVariables       #-}
{-# LANGUAGE TypeFamilies              #-}
{-# LANGUAGE TypeOperators             #-}
{-# LANGUAGE UndecidableInstances      #-}

-- TODO:
--
-- Use "start" and "end" times.
-- Body Rotation Options?
-- Filter Out Non-Moving People?
--
-- TODO: Print time
--
-- TODO: It currently crashes when it ends. We should stop the animation (or
-- loop it) when we run out of time.
--
-- TODO:
--   - If we're going for POAM we need to have a bunch of configurations that
--   let us design a particular item and then emit a file of the right type.
--
--   Basically, we need to cut off the thing. Then it works.
--
-- TODO: Visible body-part count filter
--
-- TODO: Person Re-Identification

module Main where


import           Data
import           Animation
import           Gif
import           Montage
import           DanceView
import           Control.Monad
import           Options.Generic
import           Data.Maybe
import           Data.Aeson
import           System.FilePath
import           System.FilePath.Find   hiding (directory)
import           Data.String.Conv       (toS)
import qualified Data.ByteString        as B
import qualified Data.ByteString.Lazy   as LB


main :: IO ()
main = do
    opts :: Options <- unwrapRecord "DanceView - Watch the poses generated by pose networks."

    jsonFiles <- find (depth ==? 0) (extension ==? ".json") (sourceDirectory opts)
    frames'   <- mapM readThing jsonFiles
    --
    -- Take only the frames where there is at least one person.
    let frames = filter (not . null . people) frames'

    case opts of
      DoAnimation {..} -> doAnimation frames  opts
      DoMontage   {..} -> doMontage   frames  opts
      DoGif       {..} -> doGif       frames  opts
      --
      -- We want all the frames here; we'll filter later, because we want to
      -- match it up with frame numbers.
      --
      JsonExport  {..} -> jsonExport  frames' opts


readThing :: (FromJSON a) => FilePath -> IO a
readThing f = do
    -- Note: We strictly read here because otherwise we die from too many open
    -- files. There's probably a nicer way to do this, but hey.
    file <- B.readFile f

    return $ fromMaybe (error $ "Couldn't load data from file: " ++ show file)
                       (decode' (toS file)) 


jsonExport :: [Frame] -> Options -> IO ()
jsonExport allFrames opts = do
    let directory = sourceDirectory opts </> "depth"

    threePoints <- zipWithM (\k f -> do dm <- readThing (directory </> show k <.> "json")
                                        return $ asThreePoints opts f dm
                            ) [( 0 :: Integer) ..] allFrames

    LB.writeFile (outFile opts) (encode threePoints)
